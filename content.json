{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于","text":"个人介绍软件工程专业，Java后端开发，偶尔记录一下自己平时学习、工作和生活中遇到的问题，一点一点的进步。 网站搭建本站基于Hexo静态博客框架和GitHub Pages搭建而成，朋友们若也想基于此框架搭建一套个人网站，请参考官方文档或通过搜索引擎进行操作，若仍有疑问，欢迎下方留言我们一起讨论。 网站主题主题选用Icarus，作者是ppoffice，主题风格简约现代，符合个人审美。Hexo框架有非常多好看的主题供大家选择，可以在Hexo官网主题中慢慢挑选。 主题配置主题配置参考选用主题的官方文档，本站主题参考文档为Icarus用户指南 - 主题配置。 网站分析网站分析采用不蒜子网页计数器，开启后会在网页尾部和每篇博文的头部展示访问次数，集成网站分析请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 网站分析插件。 评论系统评论系统选用gitalk，它是一个基于 GitHub Issue 和 Preact 开发的评论插件，十分方便。本站文章的评论都会在我个人仓库chengzhy.github.io的Issues中保存，集成评论系统请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 用户评论插件。 赞赏组件本站使用的主题集成了赞赏功能，本人选用支付宝和微信，只需将两者的收款码按主题的规定进行相关配置即可，集成赞赏组件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 赞赏按钮。 站内搜索本站使用主题提供的默认站内搜索功能Insight，也可以选用其它搜索插件，集成搜索插件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 站内搜索插件。 分享组件分享组件选用AddToAny，集成分享组件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 分享按钮。 其它功能目前本站只集成了以上几种功能，其它功能若需要可以参考选用主题的官方文档，本站主题的官方文档为Icarus。","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hexo网站百度谷歌收录注意事项","text":"记录一下处理百度谷歌收录本网站时遇到的问题以及注意事项。 百度、谷歌收录验证文件问题由于自己没有个人专属域名，直接使用Github Pages提供的username.github.io域名方式，所以百度、谷歌收录时的验证方式都选择文件验证的方式，它们会有一个html验证文件让放在网站的根目录下。 错误做法网上大多数的说法都是说直接把该文件放到Hexo博客根目录的source目录下，然后编译打包上传到远程仓库，但是事实上这种做法是有问题的，当执行hexo g生成静态界面的时候，hexo会把多余的内容添加到source目录下的这个html验证文件中，导致百度、谷歌验证失败。 正确做法验证文件存放在Hexo博客根目录下，等hexo g执行成功后，手动把验证文件copy到Hexo根目录下的public目录中，然后执行hexo d上传到远程仓库，这样百度、谷歌都验证成功了，为了保证一直验证成功，建议不要删除这个验证文件。 百度、谷歌收录站点地图(sitemap)获取不到问题虽然按照网上的教程使用npm下载相关依赖后(npm命令如下)， 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 执行hexo g能够在public目录下自动生成网站的sitemap，并且部署到Github上时直接通过url也能访问到sitemap.xml，但是百度、谷歌还是显示获取不到。 解决方法通过google搜索后发现，大家都有遇到类似的问题，根据大神的说法，可能不是Hexo的问题，应该是Github Pages的问题。Github Pages默认是基于Jekyll构建的，如果不是基于此方式构建的，Github Pages会忽略掉一些文件和文件夹。 因此，在Hexo博客的source文件夹下添加一个.nojekyll空文件，该文件会告诉Github Pages当前网站不是基于Jekyll构建的，不要忽略掉一些文件和文件夹。然后打开根目录下的_config.yml，找到include files区域，修改成下面这样， 123456# Include / Exclude file(s)## include:/exclude: options only apply to the 'source/' folderinclude: - .nojekyllexclude: nullignore: null 然后再**在deploy区域，添加ignore_hidden属性并设为false**。 12345# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: # 上面部分省略 ignore_hidden: false 这样在hexo g时就会把.nojekyll文件添加到public目录下，hexo d时会把.nojekyll文件推送到github上。","link":"/Hexo/SEO/Hexo%E7%BD%91%E7%AB%99%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"title":"MySQL安装指南","text":"记录一下MySQL安装过程。 安装Windows从MySQL官网下载解压版，解压至本地。 配置Windows打开此电脑 – 右键后选择属性 – 选择高级系统设置 – 点击环境变量 – 在系统环境变量Path中添加mysql路径(…\\bin)，验证是否配置成功，打开cmd，输入mysql：提示Can't connect to MySQL server on 'localhost'则证明添加成功；提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加失败，请重新检查步骤并重试。 新建配置文件my.ini放在存放mysql的根目录下，my.ini可以配置如端口、连接数等设定：(MySQL的版本≥5.5.3，可以把编码设置为utf8mb4，utf8mb4和utf8完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。) 1234567[mysqld]default-storage-engine = INNODB# 服务端使用的字符集默认为utf8mb4character-set-server = utf8mb4collation-server = utf8mb4_general_ci[client]default-character-set = utf8mb4 启动Windows初始化：管理员身份cmd输入mysqld --initialize-insecure，若无报错可以看到MySQL安装目录下已经有data目录生成。 注册服务：管理员身份cmd输入mysqld -install 启动服务：管理员身份cmd输入net start mysql 修改root用户默认密码：管理员身份cmd输入mysqladmin -u root password xxxx 登录：管理员身份cmd输入mysql -uroot -pxxxx 停止服务：管理员身份cmd输入net stop mysql 卸载mysql：停止服务后，管理员身份cmd输入mysqld -remove mysql，最后删除MySQL目录及相关的环境变量。","link":"/MySQL/%E5%AE%89%E8%A3%85/MySQL%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"},{"title":"动态规划解题方法","text":"动态规划通常用来求某个问题的最优解，将一个问题分解成若干个子问题，先求解子问题，然后从子问题的解中慢慢推导得到原问题的解。 动态规划算是做算法题时一种比较难的算法，记录一下从代码随想录的动态规划解题方法论中学到的动规做题五部曲。 动态规划题目类型 动规基础(入门：斐波那契数列、爬楼梯等) 背包问题 打家劫舍 股票问题 子序列问题 区间dp、概率dp(算法拔尖题) 动规五部曲1.知道dp数组以及下标的含义需要明白做题所定义的dp数组到底表示什么含义，以及当dp数组为一维数组时，dp[i]表示什么；当dp数组为二维数组时，dp[i][j]中的i和j分别表示什么含义。 2.递推公式(状态转移方程式)想出递推公式才能够顺利解题。 3.dp数组的初始化想明白问题最初的子问题的解是什么，初始化的值对了后面的推导才是正确的。 4.dp数组的遍历顺序考虑清楚dp数组的遍历顺序，比如有正向dp和反向dp，反向dp就会从dp数组的末尾往前推导。再比如背包问题：是先遍历背包后遍历物品还是先遍历物品再遍历背包。 5.打印dp数组当结果不对时，往往因为动规的代码比较简单而很难推断是哪里出了问题，那么将dp数组中的每一个值打印出来就能方便调试。","link":"/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95/"},{"title":"归并排序","text":"归并排序，经典的排序算法，基于分而治之的思想。 核心思想要将一个数组排序，可以先（递归地）将它分成两半，分别对这两半排序，然后再将结果归并起来。 时间复杂度时间复杂度为O(nlogn)。 空间复杂度空间复杂度为O(n)，因为需要一个额外O*(*n)空间的辅助数组来帮助归并过程。 稳定性稳定。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public int[] sortArray(int[] nums) { mergeSort(nums, 0, nums.length - 1); return nums;}/** * 归并排序 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:00 */private void mergeSort(int[] nums, int left, int right) { if (left &lt; right) { int mid = left + (right - left) / 2; /** * 分治思想：同时对左半区间和右半区间排序 * 排序完后再合并 */ mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); // 利用辅助数组合并 merge(nums, left, mid, right); }}/** * 合并区间 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param mid 中间点 * @param right 右边界 * @date 2022/2/19 13:00 */private void merge(int[] nums, int left, int mid, int right) { int[] temp = new int[right - left + 1]; int i = left, j = mid + 1, k = 0; // 将小的先添加进去 while (i &lt;= mid &amp;&amp; j &lt;= right) { temp[k++] = (nums[i] &lt; nums[j]) ? nums[i++] : nums[j++]; } // 左半区剩余 while (i &lt;= mid) { temp[k++] = nums[i++]; } // 右半区剩余 while (j &lt;= right) { temp[k++] = nums[j++]; } // 更新原数组 for (i = 0; i &lt; temp.length; i++) { nums[i + left] = temp[i]; }}","link":"/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"快速排序","text":"快速排序，经典的排序算法，用到了递归。 核心思想要将一个数组排序，先随机以一个数为基准，将比其大的数放到其右边，比其小的数放到其左边，然后再递归排以这个数为中心的左半区间和右半区间。 注意点一定要随机化选择切分元素(pivot)，否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢。 时间复杂度时间复杂度为O(nlogn)。 空间复杂度空间复杂度为O(h)，其中h为快速排序递归调用的层数。我们需要额外的O(h)的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需O(n)的空间，最优情况下每次都平衡，此时整个递归树高度为logn，空间复杂度为O(logn)。 稳定性不稳定。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums;}/** * 快速排序 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:35 */private void quickSort(int[] nums, int left, int right) { if (left &lt; right) { /** * 核心思想：以一个数为基准，将比其大的数放到其右边，比其小的数放到其左边 * 然后再递归排以这个数为中心的左半区间和右半区间 */ int i = partition(nums, left, right); quickSort(nums, left, i - 1); quickSort(nums, i + 1, right); }}/** * 分隔(选取一个数作为基准，将比其大的数放到其右边，比其小的数放到其左边) * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:35 * @return 分隔后基准数的下标值 */private int partition(int[] nums, int left, int right) { /** * 优化点：针对特殊测试用例：顺序数组或者逆序数组，一定要随机化选择切分元素（pivot）， * 否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢 */ int randomIndex = left + new Random().nextInt(right - left + 1); int temp = nums[left]; nums[left] = nums[randomIndex]; nums[randomIndex] = temp; // 将区间的第一个数作为基准 int base = nums[left]; int i = left, j = right; while (i &lt; j) { // 循环找比基数小和比基数大的数 // 先去找第一个比基数小的数的位置 while (base &lt;= nums[j] &amp;&amp; i &lt; j) { j--; } // 再去找第一个比基数大的数的位置 while (base &gt;= nums[i] &amp;&amp; i &lt; j) { i++; } if (i &lt; j) { // 如果i在j的左边，则交换两个位置的数 temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } // 将基数放至中心位置 nums[left] = nums[i]; nums[i] = base; // 返回基数的位置 return i;}","link":"/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github Pages","slug":"Github-Pages","link":"/tags/Github-Pages/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"指南","slug":"指南","link":"/tags/%E6%8C%87%E5%8D%97/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"SEO","slug":"Hexo/SEO","link":"/categories/Hexo/SEO/"},{"name":"安装","slug":"MySQL/安装","link":"/categories/MySQL/%E5%AE%89%E8%A3%85/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"排序算法","slug":"算法/排序算法","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"归并排序","slug":"算法/排序算法/归并排序","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"算法/排序算法/快速排序","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]}