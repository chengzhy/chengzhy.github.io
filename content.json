{"pages":[{"title":"关于","text":"个人介绍软件工程专业，Java后端开发，偶尔记录一下自己平时学习、工作和生活中遇到的问题，一点一点的进步。 网站搭建本站基于Hexo静态博客框架和GitHub Pages搭建而成，朋友们若也想基于此框架搭建一套个人网站，请参考官方文档或通过搜索引擎进行操作，若仍有疑问，欢迎下方留言我们一起讨论。 网站主题主题选用Icarus，作者是ppoffice，主题风格简约现代，符合个人审美。Hexo框架有非常多好看的主题供大家选择，可以在Hexo官网主题中慢慢挑选。 主题配置主题配置参考选用主题的官方文档，本站主题参考文档为Icarus用户指南 - 主题配置。 网站分析网站分析采用不蒜子网页计数器，开启后会在网页尾部和每篇博文的头部展示访问次数，集成网站分析请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 网站分析插件。 评论系统评论系统选用gitalk，它是一个基于 GitHub Issue 和 Preact 开发的评论插件，十分方便。本站文章的评论都会在我个人仓库chengzhy.github.io的Issues中保存，集成评论系统请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 用户评论插件。 赞赏组件本站使用的主题集成了赞赏功能，本人选用支付宝和微信，只需将两者的收款码按主题的规定进行相关配置即可，集成赞赏组件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 赞赏按钮。 站内搜索本站使用主题提供的默认站内搜索功能Insight，也可以选用其它搜索插件，集成搜索插件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 站内搜索插件。 分享组件分享组件选用AddToAny，集成分享组件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 分享按钮。 其它功能目前本站只集成了以上几种功能，其它功能若需要可以参考选用主题的官方文档，本站主题的官方文档为Icarus。","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hexo网站百度谷歌收录注意事项","text":"记录一下处理百度谷歌收录本网站时遇到的问题以及注意事项。 百度、谷歌收录验证文件问题由于自己没有个人专属域名，直接使用Github Pages提供的username.github.io域名方式，所以百度、谷歌收录时的验证方式都选择文件验证的方式，它们会有一个html验证文件让放在网站的根目录下。 错误做法网上大多数的说法都是说直接把该文件放到Hexo博客根目录的source目录下，然后编译打包上传到远程仓库，但是事实上这种做法是有问题的，当执行hexo g生成静态界面的时候，hexo会把多余的内容添加到source目录下的这个html验证文件中，导致百度、谷歌验证失败。 正确做法验证文件存放在Hexo博客根目录下，等hexo g执行成功后，手动把验证文件copy到Hexo根目录下的public目录中，然后执行hexo d上传到远程仓库，这样百度、谷歌都验证成功了，为了保证一直验证成功，建议不要删除这个验证文件。 百度、谷歌收录站点地图(sitemap)获取不到问题虽然按照网上的教程使用npm下载相关依赖后(npm命令如下)， 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 执行hexo g能够在public目录下自动生成网站的sitemap，并且部署到Github上时直接通过url也能访问到sitemap.xml，但是百度、谷歌还是显示获取不到。 解决方法通过google搜索后发现，大家都有遇到类似的问题，根据大神的说法，可能不是Hexo的问题，应该是Github Pages的问题。Github Pages默认是基于Jekyll构建的，如果不是基于此方式构建的，Github Pages会忽略掉一些文件和文件夹。 因此，在Hexo博客的source文件夹下添加一个.nojekyll空文件，该文件会告诉Github Pages当前网站不是基于Jekyll构建的，不要忽略掉一些文件和文件夹。然后打开根目录下的_config.yml，找到include files区域，修改成下面这样， 123456# Include / Exclude file(s)## include:/exclude: options only apply to the 'source/' folderinclude: - .nojekyllexclude: nullignore: null 然后再**在deploy区域，添加ignore_hidden属性并设为false**。 12345# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: # 上面部分省略 ignore_hidden: false 这样在hexo g时就会把.nojekyll文件添加到public目录下，hexo d时会把.nojekyll文件推送到github上。","link":"/Hexo/SEO/Hexo%E7%BD%91%E7%AB%99%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"title":"LeetCode动态规划之子序列问题必刷题目","text":"按照以下顺序刷题，能对动态规划之子序列问题有更深刻的理解。 300. 最长递增子序列 674. 最长连续递增序列 718. 最长重复子数组 1143. 最长公共子序列 1035. 不相交的线 53. 最大子数组和 392. 判断子序列 115. 不同的子序列 583. 两个字符串的删除操作 72. 编辑距离 647. 回文子串 516. 最长回文子序列","link":"/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/LeetCode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E5%BF%85%E5%88%B7%E9%A2%98%E7%9B%AE/"},{"title":"LeetCode动态规划之打家劫舍问题必刷题目","text":"按照以下顺序刷题，能对动态规划之打家劫舍问题有更深刻的理解。 198. 打家劫舍 213. 打家劫舍 II 337. 打家劫舍 III","link":"/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/LeetCode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98%E5%BF%85%E5%88%B7%E9%A2%98%E7%9B%AE/"},{"title":"LeetCode动态规划之股票问题必刷题目","text":"按照以下顺序刷题，能对动态规划之股票问题有更深刻的理解。 121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 309. 最佳买卖股票时机含冷冻期 714. 买卖股票的最佳时机含手续费","link":"/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/LeetCode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E5%BF%85%E5%88%B7%E9%A2%98%E7%9B%AE/"},{"title":"LeetCode动态规划之背包问题必刷题目","text":"按照以下顺序刷题，能对动态规划之背包问题有更深刻的理解。 0-1背包 416. 分割等和子集 1049. 最后一块石头的重量 II 494. 目标和 474. 一和零 879. 盈利计划 完全背包 518. 零钱兑换 II 377. 组合总和 Ⅳ 70. 爬楼梯 322. 零钱兑换 279. 完全平方数 139. 单词拆分 1449. 数位成本和为目标值的最大数字","link":"/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/LeetCode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%BF%85%E5%88%B7%E9%A2%98%E7%9B%AE/"},{"title":"MySQL安装指南","text":"记录一下MySQL安装过程。 安装Windows从MySQL官网下载解压版，解压至本地。 配置Windows打开此电脑 – 右键后选择属性 – 选择高级系统设置 – 点击环境变量 – 在系统环境变量Path中添加mysql路径(…\\bin)，验证是否配置成功，打开cmd，输入mysql：提示Can't connect to MySQL server on 'localhost'则证明添加成功；提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加失败，请重新检查步骤并重试。 新建配置文件my.ini放在存放mysql的根目录下，my.ini可以配置如端口、连接数等设定：(MySQL的版本≥5.5.3，可以把编码设置为utf8mb4，utf8mb4和utf8完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。) 1234567[mysqld]default-storage-engine = INNODB# 服务端使用的字符集默认为utf8mb4character-set-server = utf8mb4collation-server = utf8mb4_general_ci[client]default-character-set = utf8mb4 启动Windows初始化：管理员身份cmd输入mysqld --initialize-insecure，若无报错可以看到MySQL安装目录下已经有data目录生成。 注册服务：管理员身份cmd输入mysqld -install 启动服务：管理员身份cmd输入net start mysql 修改root用户默认密码：管理员身份cmd输入mysqladmin -u root password xxxx 登录：管理员身份cmd输入mysql -uroot -pxxxx 停止服务：管理员身份cmd输入net stop mysql 卸载mysql：停止服务后，管理员身份cmd输入mysqld -remove mysql，最后删除MySQL目录及相关的环境变量。","link":"/MySQL/%E5%AE%89%E8%A3%85/MySQL%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"},{"title":"动态规划之01背包问题解题方法","text":"01背包是背包问题的理论基础，完全背包也是经过01背包演变而来的。LeetCode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要将其转化为01背包问题。所以，记录一下从代码随想录-01背包理论基础学习到纯01背包问题的解题方法，具体应用题需要靠自己来将其转化成01背包，dp数组状态转移方程、初始化可能会和纯01背包问题有一些不同，需要具体问题具体分析。 概念有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 例子背包最大重量为4，物品的重量和价值如下： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 解题方法动规五部曲 1.确定dp数组以及下标的含义使用二维数组，dp[i][j]数组表示从前i个物品中任意取，放进容量为j的背包中所得到的物品的最大价值。 2.递推公式(状态转移方程式)对于每个物品来说有两种选择，不选取或选取。所以dp[i][j]可以从这两类选择中推导出： 不选取物品i： 由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，即dp[i][j] = dp[i - 1][j]。 选取物品i： 由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]]表示背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i]（物品i的价值） ，就是背包放物品i得到的最大价值，即dp[i][j] = dp[i - 1][j - weight[i]] + value[i]。 所以，递推公式为： 如果物品i的重量大于背包容量j时，背包放不下，就不能选择物品i，dp[i][j] = dp[i - 1][j]； 如果物品i的重量小于等于背包容量j时，dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])。 3.dp数组的初始化关于初始化，一定要和dp数组的定义一致。 两种初始化情况： 背包容量j为0，不管选择哪些物品，所得到的物品最大价值一定为0，所以dp[i][0] = 0； 物品数量为0时，不论背包容量多大，所得到的物品最大价值一定为0，所以dp[0][j] = 0。 dp[i][j](物品\\背包) 0 1 2 3 4 无物品 0 0 0 0 0 物品0 0 物品1 0 物品2 0 4.dp数组的遍历顺序有两个遍历的维度：物品和背包，那么问题来了，先遍历物品还是先遍历背包重量呢？ 其实都可以，因为递推公式为dp[i][j] = dp[i - 1][j]和dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])这两种情况，不论哪种，dp[i - 1][j]和dp[i - 1][j - weight[i]]都在dp[i][j]的左上角方向，而两种遍历顺序都能够获取到dp[i][j]左上角方向的值，先遍历物品会更好理解。 先遍历物品再遍历背包，代码如下 12345678910111213// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];for (int i = 1; i &lt;= m; i++) { // 遍历物品 for (int j = 0; j &lt;= n; j++) { // 遍历背包 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } }} 先遍历背包再遍历物品，代码如下 12345678910111213// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];for (int j = 0; j &lt;= n; j++) { // 遍历背包 for (int i = 1; i &lt;= m; i++) { // 遍历物品 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } }} 5.打印dp数组dp数组对应值如下： dp[i][j](物品\\背包) 0 1 2 3 4 无物品 0 0 0 0 0 物品0(重量1，价值15) 0 15 15 15 15 物品1(重量3，价值20) 0 15 15 20 35 物品2(重量4，价值30) 0 15 15 20 35 完整代码123456789101112131415// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];// dp[i][0]和dp[0][j]情况的初始化省略，因为dp数组的默认值就是0for (int i = 1; i &lt;= m; i++) { // 遍历物品 for (int j = 0; j &lt;= n; j++) { // 遍历背包 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } }}return dp[m][n]; 优化为一维dp数组由于递推公式中dp[i][j]都是用到了dp[i - 1]即上一层的数据，所以可以将dp[i][j]优化为dp[j]。 dp数组以及下标的含义这里dp[j]数组的表示容量为j的背包中所得到的物品的最大价值。 递推公式(状态转移方程式)递推公式变为dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])。 dp数组的初始化dp[0] = 0即可 dp数组的遍历顺序123456789// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;int[] dp = new int[n + 1];for (int i = 1; i &lt;= m; i++) { // 注意这里遍历背包顺序变成了倒序，很重要 for (int j = n; j &gt;= weight[i - 1]; j--) { dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); }} 为什么这里背包从大到小倒序遍历？倒序遍历是为了保证物品i只被放入一次！如果一旦正序遍历了，那么物品0就会被重复加入多次！ 举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15，如果正序遍历，dp[1] = dp[1 - weight[0]] + value[0] = 15，dp[2] = dp[2 - weight[0]] + value[0] = 30，此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。 为什么倒序遍历，就可以保证物品只放入一次呢？倒序就是先算dp[2]，dp[2] = dp[2 - weight[0]] + value[0] = 15（dp数组已经都初始化为0），dp[1] = dp[1 - weight[0]] + value[0] = 15 所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。 为什么二维dp数组历的时候不用倒序呢？因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖。 这里可不可以先遍历背包容量嵌套遍历物品呢？不可以！因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即背包里只放入了一个物品。 打印dp数组略 一维数组完整代码12345678910// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;int[] dp = new int[n + 1];for (int i = 1; i &lt;= m; i++) { // 注意这里遍历背包顺序变成了倒序，很重要 for (int j = n; j &gt;= weight[i - 1]; j--) { dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); }}return dp[n];","link":"/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95/"},{"title":"动态规划解题方法","text":"动态规划通常用来求某个问题的最优解，将一个问题分解成若干个子问题，先求解子问题，然后从子问题的解中慢慢推导得到原问题的解。 动态规划算是做算法题时一种比较难的算法，记录一下从代码随想录的动态规划解题方法论中学到的动规做题五部曲。 动态规划题目类型 动规基础(入门：斐波那契数列、爬楼梯等) 背包问题 打家劫舍 股票问题 子序列问题 区间dp、概率dp(算法拔尖题) 动规五部曲1.确定dp数组以及下标的含义需要明白做题所定义的dp数组到底表示什么含义，以及当dp数组为一维数组时，dp[i]表示什么；当dp数组为二维数组时，dp[i][j]中的i和j分别表示什么含义。 2.递推公式(状态转移方程式)想出递推公式才能够顺利解题。 3.dp数组的初始化想明白问题最初的子问题的解是什么，初始化的值对了后面的推导才是正确的。 4.dp数组的遍历顺序考虑清楚dp数组的遍历顺序，比如有正向dp和反向dp，反向dp就会从dp数组的末尾往前推导。再比如背包问题：是先遍历背包后遍历物品还是先遍历物品再遍历背包。 5.打印dp数组当结果不对时，往往因为动规的代码比较简单而很难推断是哪里出了问题，那么将dp数组中的每一个值打印出来就能方便调试。","link":"/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95/"},{"title":"动态规划之完全背包问题解题方法","text":"完全背包是经过01背包演变而来的，区别就是完全背包问题中物品是有无限个的，也就是说一个物品可以放入背包多次。同样的LeetCode上也没有纯完全背包的问题，都是完全背包应用方面的题目，也就是需要将其转化为完全背包问题。所以，记录一下从代码随想录-完全背包理论基础学习到纯完全背包问题的解题方法，补充一下纯完全背包的二维dp数组的解法，具体应用题需要靠自己来将其转化成完全背包，dp数组状态转移方程、初始化、遍历顺序可能会和纯完全背包问题有一些不同，需要具体问题具体分析。 概念有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品有无限个，即一个物品可以放入背包多次，求解将哪些物品装入背包里物品价值总和最大。 例子背包最大重量为4，每个物品有无限个，物品的重量和价值如下： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 解题方法动规五部曲 1.确定dp数组以及下标的含义使用二维数组，dp[i][j]数组表示从前i个物品中任意取，放进容量为j的背包中所得到的物品的最大价值。 2.递推公式(状态转移方程式)对于每个物品来说有两种选择，不选取或选取。所以dp[i][j]可以从这两类选择中推导出： 不选取物品i： 由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，即dp[i][j] = dp[i - 1][j]。 选取物品i： **由dp[i][j - weight[i]]推出，注意这里和01背包的区别，因为可以重复放物品i，所以是dp[i][j - weight[i]]**，表示背包容量为j - weight[i]的时候任取物品i的最大价值，那么dp[i][j - weight[i]] + value[i]（物品i的价值） ，就是背包放物品i得到的最大价值，即dp[i][j] = dp[i][j - weight[i]] + value[i]。 所以，递推公式为： 如果物品i的重量大于背包容量j时，背包放不下，就不能选择物品i，dp[i][j] = dp[i - 1][j]； 如果物品i的重量小于等于背包容量j时，dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])。 3.dp数组的初始化关于初始化，一定要和dp数组的定义一致。 两种初始化情况： 背包容量j为0，不管选择哪些物品，所得到的物品最大价值一定为0，所以dp[i][0] = 0； 物品数量为0时，不论背包容量多大，所得到的物品最大价值一定为0，所以dp[0][j] = 0。 dp[i][j](物品\\背包) 0 1 2 3 4 无物品 0 0 0 0 0 物品0 0 物品1 0 物品2 0 4.dp数组的遍历顺序有两个遍历的维度：物品和背包，那么问题来了，先遍历物品还是先遍历背包重量呢？ 其实都可以，因为递推公式为dp[i][j] = dp[i - 1][j]和dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])这两种情况，不论哪种，dp[i - 1][j]和dp[i][j - weight[i]]都在dp[i][j]的左上角方向，而两种遍历顺序都能够获取到dp[i][j]左上角方向的值，先遍历物品会更好理解。 先遍历物品再遍历背包，代码如下 1234567891011121314// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];for (int i = 1; i &lt;= m; i++) { // 遍历物品 for (int j = 0; j &lt;= n; j++) { // 遍历背包 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { // 注意这里跟01背包只有下面一个下标不同，那就是“放i”这个选择，因为是可以重复放的，所以是dp[i] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i - 1]] + value[i - 1]); } }} 先遍历背包再遍历物品，代码如下 1234567891011121314// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];for (int j = 0; j &lt;= n; j++) { // 遍历背包 for (int i = 1; i &lt;= m; i++) { // 遍历物品 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { // 注意这里跟01背包只有下面一个下标不同，那就是“放i”这个选择，因为是可以重复放的，所以是dp[i] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i - 1]] + value[i - 1]); } }} 5.打印dp数组dp数组对应值如下： dp[i][j](物品\\背包) 0 1 2 3 4 无物品 0 0 0 0 0 物品0(重量1，价值15) 0 15 30 45 60 物品1(重量3，价值20) 0 15 30 45 60 物品2(重量4，价值30) 0 15 30 45 60 完整代码12345678910111213141516// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];// dp[i][0]和dp[0][j]情况的初始化省略，因为dp数组的默认值就是0for (int i = 1; i &lt;= m; i++) { // 遍历物品 for (int j = 0; j &lt;= n; j++) { // 遍历背包 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { // 注意这里跟01背包只有下面一个下标不同，那就是“放i”这个选择，因为是可以重复放的，所以是dp[i] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i - 1]] + value[i - 1]); } }}return dp[m][n]; 优化为一维dp数组由于递推公式中dp[i][j]用到了dp[i - 1][j]和dp[i][j - weight[i]]即上一层和左边的数据，所以可以将dp[i][j]优化为dp[j]。 dp数组以及下标的含义这里dp[j]数组的表示容量为j的背包中所得到的物品的最大价值。 递推公式(状态转移方程式)递推公式变为dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])。 dp数组的初始化dp[0] = 0即可 dp数组的遍历顺序01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次；而完全背包的物品是可以添加多次的，所以要从小到大去遍历。 123456789// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;int[] dp = new int[n + 1];for (int i = 1; i &lt;= m; i++) { // 注意这里遍历背包顺序又变成了正序，和01背包不同，很重要 for (int j = weight[i - 1]; j &lt;= n; j++) { dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); }} 这里完全背包一维dp数组可以交换遍历顺序吗？和01背包不同，这里是可以的！因为dp[j]是用到其左边的数据dp[j - weight[i]]的，而先遍历背包再遍历物品也是满足的。 打印dp数组略 一维数组完整代码12345678910// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;int[] dp = new int[n + 1];for (int i = 1; i &lt;= m; i++) { // 注意这里遍历背包顺序又变成了正序，和01背包不同，很重要 for (int j = weight[i - 1]; j &lt;= n; j++) { dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); }}return dp[n];","link":"/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95/"},{"title":"快速排序","text":"快速排序，经典的排序算法，用到了递归。 核心思想要将一个数组排序，先随机以一个数为基准，将比其大的数放到其右边，比其小的数放到其左边，然后再递归排以这个数为中心的左半区间和右半区间。 注意点一定要随机化选择切分元素(pivot)，否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢。 时间复杂度时间复杂度为O(nlogn)。 空间复杂度空间复杂度为O(h)，其中h为快速排序递归调用的层数。我们需要额外的O(h)的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需O(n)的空间，最优情况下每次都平衡，此时整个递归树高度为logn，空间复杂度为O(logn)。 稳定性不稳定。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums;}/** * 快速排序 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:35 */private void quickSort(int[] nums, int left, int right) { if (left &lt; right) { /** * 核心思想：以一个数为基准，将比其大的数放到其右边，比其小的数放到其左边 * 然后再递归排以这个数为中心的左半区间和右半区间 */ int i = partition(nums, left, right); quickSort(nums, left, i - 1); quickSort(nums, i + 1, right); }}/** * 分隔(选取一个数作为基准，将比其大的数放到其右边，比其小的数放到其左边) * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:35 * @return 分隔后基准数的下标值 */private int partition(int[] nums, int left, int right) { /** * 优化点：针对特殊测试用例：顺序数组或者逆序数组，一定要随机化选择切分元素（pivot）， * 否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢 */ int randomIndex = left + new Random().nextInt(right - left + 1); int temp = nums[left]; nums[left] = nums[randomIndex]; nums[randomIndex] = temp; // 将区间的第一个数作为基准 int base = nums[left]; int i = left, j = right; while (i &lt; j) { // 循环找比基数小和比基数大的数 // 先去找第一个比基数小的数的位置 while (base &lt;= nums[j] &amp;&amp; i &lt; j) { j--; } // 再去找第一个比基数大的数的位置 while (base &gt;= nums[i] &amp;&amp; i &lt; j) { i++; } if (i &lt; j) { // 如果i在j的左边，则交换两个位置的数 temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } // 将基数放至中心位置 nums[left] = nums[i]; nums[i] = base; // 返回基数的位置 return i;}","link":"/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"归并排序","text":"归并排序，经典的排序算法，基于分而治之的思想。 核心思想要将一个数组排序，可以先（递归地）将它分成两半，分别对这两半排序，然后再将结果归并起来。 时间复杂度时间复杂度为O(nlogn)。 空间复杂度空间复杂度为O(n)，因为需要一个额外O*(*n)空间的辅助数组来帮助归并过程。 稳定性稳定。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public int[] sortArray(int[] nums) { mergeSort(nums, 0, nums.length - 1); return nums;}/** * 归并排序 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:00 */private void mergeSort(int[] nums, int left, int right) { if (left &lt; right) { int mid = left + (right - left) / 2; /** * 分治思想：同时对左半区间和右半区间排序 * 排序完后再合并 */ mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); // 利用辅助数组合并 merge(nums, left, mid, right); }}/** * 合并区间 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param mid 中间点 * @param right 右边界 * @date 2022/2/19 13:00 */private void merge(int[] nums, int left, int mid, int right) { int[] temp = new int[right - left + 1]; int i = left, j = mid + 1, k = 0; // 将小的先添加进去 while (i &lt;= mid &amp;&amp; j &lt;= right) { temp[k++] = (nums[i] &lt; nums[j]) ? nums[i++] : nums[j++]; } // 左半区剩余 while (i &lt;= mid) { temp[k++] = nums[i++]; } // 右半区剩余 while (j &lt;= right) { temp[k++] = nums[j++]; } // 更新原数组 for (i = 0; i &lt; temp.length; i++) { nums[i + left] = temp[i]; }}","link":"/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github Pages","slug":"Github-Pages","link":"/tags/Github-Pages/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"指南","slug":"指南","link":"/tags/%E6%8C%87%E5%8D%97/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"SEO","slug":"Hexo/SEO","link":"/categories/Hexo/SEO/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"安装","slug":"MySQL/安装","link":"/categories/MySQL/%E5%AE%89%E8%A3%85/"},{"name":"子序列问题","slug":"算法/动态规划/子序列问题","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"},{"name":"打家劫舍","slug":"算法/动态规划/打家劫舍","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"name":"股票问题","slug":"算法/动态规划/股票问题","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"},{"name":"背包问题","slug":"算法/动态规划/背包问题","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"01背包","slug":"算法/动态规划/背包问题/01背包","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85/"},{"name":"完全背包","slug":"算法/动态规划/背包问题/完全背包","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"},{"name":"排序算法","slug":"算法/排序算法","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"快速排序","slug":"算法/排序算法/快速排序","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"算法/排序算法/归并排序","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}]}