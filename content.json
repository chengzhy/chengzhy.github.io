{"pages":[{"title":"","text":"google-site-verification: googleb12277d693c4370c.html","link":"/googleb12277d693c4370c.html"},{"title":"","text":"822492168df45a8a7e895b1559d72e12","link":"/baidu_verify_code-em2oyNStV6.html"},{"title":"关于","text":"个人介绍软件工程专业，Java后端开发，偶尔记录一下自己平时学习、工作和生活中遇到的问题，一点一点的进步。 网站搭建本站基于Hexo静态博客框架和GitHub Pages搭建而成，朋友们若也想基于此框架搭建一套个人网站，请参考官方文档或通过搜索引擎进行操作，若仍有疑问，欢迎下方留言我们一起讨论。 网站主题主题选用Icarus，作者是ppoffice，主题风格简约现代，符合个人审美。Hexo框架有非常多好看的主题供大家选择，可以在Hexo官网主题中慢慢挑选。 主题配置主题配置参考选用主题的官方文档，本站主题参考文档为Icarus用户指南 - 主题配置。 网站分析网站分析采用不蒜子网页计数器，开启后会在网页尾部和每篇博文的头部展示访问次数，集成网站分析请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 网站分析插件。 评论系统评论系统选用gitalk，它是一个基于 GitHub Issue 和 Preact 开发的评论插件，十分方便。本站文章的评论都会在我个人仓库chengzhy.github.io的Issues中保存，集成评论系统请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 用户评论插件。 赞赏组件本站使用的主题集成了赞赏功能，本人选用支付宝和微信，只需将两者的收款码按主题的规定进行相关配置即可，集成赞赏组件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 赞赏按钮。 站内搜索本站使用主题提供的默认站内搜索功能Insight，也可以选用其它搜索插件，集成搜索插件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 站内搜索插件。 分享组件分享组件选用AddToAny，集成分享组件请参考所使用主题的官方文档，本站主题参考文档为Icarus用户指南 - 分享按钮。 其它功能目前本站只集成了以上几种功能，其它功能若需要可以参考选用主题的官方文档，本站主题的官方文档为Icarus。","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"动态规划之01背包问题解题方法","text":"01背包是背包问题的理论基础，完全背包也是经过01背包演变而来的。LeetCode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要将其转化为01背包问题。所以，记录一下从代码随想录-01背包理论基础学习到纯01背包问题的解题方法，具体应用题需要靠自己来将其转化成01背包，dp数组状态转移方程、初始化可能会和纯01背包问题有一些不同，需要具体问题具体分析。 概念有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 例子背包最大重量为4，物品的重量和价值如下： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 解题方法动规五部曲 1.确定dp数组以及下标的含义使用二维数组，dp[i][j]数组表示从前i个物品中任意取，放进容量为j的背包中所得到的物品的最大价值。 2.递推公式(状态转移方程式)对于每个物品来说有两种选择，不选取或选取。所以dp[i][j]可以从这两类选择中推导出： 不选取物品i： 由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，即dp[i][j] = dp[i - 1][j]。 选取物品i： 由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]]表示背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i]（物品i的价值） ，就是背包放物品i得到的最大价值，即dp[i][j] = dp[i - 1][j - weight[i]] + value[i]。 所以，递推公式为： 如果物品i的重量大于背包容量j时，背包放不下，就不能选择物品i，dp[i][j] = dp[i - 1][j]； 如果物品i的重量小于等于背包容量j时，dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])。 3.dp数组的初始化关于初始化，一定要和dp数组的定义一致。 两种初始化情况： 背包容量j为0，不管选择哪些物品，所得到的物品最大价值一定为0，所以dp[i][0] = 0； 物品数量为0时，不论背包容量多大，所得到的物品最大价值一定为0，所以dp[0][j] = 0。 dp[i][j](物品\\背包) 0 1 2 3 4 无物品 0 0 0 0 0 物品0 0 物品1 0 物品2 0 4.dp数组的遍历顺序有两个遍历的维度：物品和背包，那么问题来了，先遍历物品还是先遍历背包重量呢？ 其实都可以，因为递推公式为dp[i][j] = dp[i - 1][j]和dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])这两种情况，不论哪种，dp[i - 1][j]和dp[i - 1][j - weight[i]]都在dp[i][j]的左上角方向，而两种遍历顺序都能够获取到dp[i][j]左上角方向的值，先遍历物品会更好理解。 先遍历物品再遍历背包，代码如下 12345678910111213// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];for (int i = 1; i &lt;= m; i++) { // 遍历物品 for (int j = 0; j &lt;= n; j++) { // 遍历背包 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } }} 先遍历背包再遍历物品，代码如下 12345678910111213// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];for (int j = 0; j &lt;= n; j++) { // 遍历背包 for (int i = 1; i &lt;= m; i++) { // 遍历物品 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } }} 5.打印dp数组dp数组对应值如下： dp[i][j](物品\\背包) 0 1 2 3 4 无物品 0 0 0 0 0 物品0(重量1，价值15) 0 15 15 15 15 物品1(重量3，价值20) 0 15 15 20 35 物品2(重量4，价值30) 0 15 15 20 35 完整代码123456789101112131415// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];// dp[i][0]和dp[0][j]情况的初始化省略，因为dp数组的默认值就是0for (int i = 1; i &lt;= m; i++) { // 遍历物品 for (int j = 0; j &lt;= n; j++) { // 遍历背包 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); } }}return dp[m][n]; 优化为一维dp数组由于递推公式中dp[i][j]都是用到了dp[i - 1]即上一层的数据，所以可以将dp[i][j]优化为dp[j]。 dp数组以及下标的含义这里dp[j]数组的表示容量为j的背包中所得到的物品的最大价值。 递推公式(状态转移方程式)递推公式变为dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])。 dp数组的初始化dp[0] = 0即可 dp数组的遍历顺序123456789// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;int[] dp = new int[n + 1];for (int i = 1; i &lt;= m; i++) { // 注意这里遍历背包顺序变成了倒序，很重要 for (int j = n; j &gt;= weight[i - 1]; j--) { dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); }} 为什么这里背包从大到小倒序遍历？倒序遍历是为了保证物品i只被放入一次！如果一旦正序遍历了，那么物品0就会被重复加入多次！ 举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15，如果正序遍历，dp[1] = dp[1 - weight[0]] + value[0] = 15，dp[2] = dp[2 - weight[0]] + value[0] = 30，此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。 为什么倒序遍历，就可以保证物品只放入一次呢？倒序就是先算dp[2]，dp[2] = dp[2 - weight[0]] + value[0] = 15（dp数组已经都初始化为0），dp[1] = dp[1 - weight[0]] + value[0] = 15 所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。 为什么二维dp数组历的时候不用倒序呢？因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖。 这里可不可以先遍历背包容量嵌套遍历物品呢？不可以！因为一维dp的写法，背包容量一定是要倒序遍历，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即背包里只放入了一个物品。 打印dp数组略 一维数组完整代码12345678910// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;int[] dp = new int[n + 1];for (int i = 1; i &lt;= m; i++) { // 注意这里遍历背包顺序变成了倒序，很重要 for (int j = n; j &gt;= weight[i - 1]; j--) { dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); }}return dp[n];","link":"/2022/01-knapsack-problem-solving-method/"},{"title":"动态规划之完全背包问题解题方法","text":"完全背包是经过01背包演变而来的，区别就是完全背包问题中物品是有无限个的，也就是说一个物品可以放入背包多次。同样的LeetCode上也没有纯完全背包的问题，都是完全背包应用方面的题目，也就是需要将其转化为完全背包问题。所以，记录一下从代码随想录-完全背包理论基础学习到纯完全背包问题的解题方法，补充一下纯完全背包的二维dp数组的解法，具体应用题需要靠自己来将其转化成完全背包，dp数组状态转移方程、初始化、遍历顺序可能会和纯完全背包问题有一些不同，需要具体问题具体分析。 概念有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品有无限个，即一个物品可以放入背包多次，求解将哪些物品装入背包里物品价值总和最大。 例子背包最大重量为4，每个物品有无限个，物品的重量和价值如下： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 解题方法动规五部曲 1.确定dp数组以及下标的含义使用二维数组，dp[i][j]数组表示从前i个物品中任意取，放进容量为j的背包中所得到的物品的最大价值。 2.递推公式(状态转移方程式)对于每个物品来说有两种选择，不选取或选取。所以dp[i][j]可以从这两类选择中推导出： 不选取物品i： 由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，即dp[i][j] = dp[i - 1][j]。 选取物品i： **由dp[i][j - weight[i]]推出，注意这里和01背包的区别，因为可以重复放物品i，所以是dp[i][j - weight[i]]**，表示背包容量为j - weight[i]的时候任取物品i的最大价值，那么dp[i][j - weight[i]] + value[i]（物品i的价值） ，就是背包放物品i得到的最大价值，即dp[i][j] = dp[i][j - weight[i]] + value[i]。 所以，递推公式为： 如果物品i的重量大于背包容量j时，背包放不下，就不能选择物品i，dp[i][j] = dp[i - 1][j]； 如果物品i的重量小于等于背包容量j时，dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])。 3.dp数组的初始化关于初始化，一定要和dp数组的定义一致。 两种初始化情况： 背包容量j为0，不管选择哪些物品，所得到的物品最大价值一定为0，所以dp[i][0] = 0； 物品数量为0时，不论背包容量多大，所得到的物品最大价值一定为0，所以dp[0][j] = 0。 dp[i][j](物品\\背包) 0 1 2 3 4 无物品 0 0 0 0 0 物品0 0 物品1 0 物品2 0 4.dp数组的遍历顺序有两个遍历的维度：物品和背包，那么问题来了，先遍历物品还是先遍历背包重量呢？ 其实都可以，因为递推公式为dp[i][j] = dp[i - 1][j]和dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])这两种情况，不论哪种，dp[i - 1][j]和dp[i][j - weight[i]]都在dp[i][j]的左上角方向，而两种遍历顺序都能够获取到dp[i][j]左上角方向的值，先遍历物品会更好理解。 先遍历物品再遍历背包，代码如下 1234567891011121314// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];for (int i = 1; i &lt;= m; i++) { // 遍历物品 for (int j = 0; j &lt;= n; j++) { // 遍历背包 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { // 注意这里跟01背包只有下面一个下标不同，那就是“放i”这个选择，因为是可以重复放的，所以是dp[i] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i - 1]] + value[i - 1]); } }} 先遍历背包再遍历物品，代码如下 1234567891011121314// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];for (int j = 0; j &lt;= n; j++) { // 遍历背包 for (int i = 1; i &lt;= m; i++) { // 遍历物品 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { // 注意这里跟01背包只有下面一个下标不同，那就是“放i”这个选择，因为是可以重复放的，所以是dp[i] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i - 1]] + value[i - 1]); } }} 5.打印dp数组dp数组对应值如下： dp[i][j](物品\\背包) 0 1 2 3 4 无物品 0 0 0 0 0 物品0(重量1，价值15) 0 15 30 45 60 物品1(重量3，价值20) 0 15 30 45 60 物品2(重量4，价值30) 0 15 30 45 60 完整代码12345678910111213141516// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况int[][] dp = new int[m + 1][n + 1];// dp[i][0]和dp[0][j]情况的初始化省略，因为dp数组的默认值就是0for (int i = 1; i &lt;= m; i++) { // 遍历物品 for (int j = 0; j &lt;= n; j++) { // 遍历背包 if (j &lt; weight[i - 1]) { dp[i][j] = dp[i - 1][j]; } else { // 注意这里跟01背包只有下面一个下标不同，那就是“放i”这个选择，因为是可以重复放的，所以是dp[i] dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i - 1]] + value[i - 1]); } }}return dp[m][n]; 优化为一维dp数组由于递推公式中dp[i][j]用到了dp[i - 1][j]和dp[i][j - weight[i]]即上一层和左边的数据，所以可以将dp[i][j]优化为dp[j]。 dp数组以及下标的含义这里dp[j]数组的表示容量为j的背包中所得到的物品的最大价值。 递推公式(状态转移方程式)递推公式变为dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])。 dp数组的初始化dp[0] = 0即可 dp数组的遍历顺序01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次；而完全背包的物品是可以添加多次的，所以要从小到大去遍历。 123456789// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;int[] dp = new int[n + 1];for (int i = 1; i &lt;= m; i++) { // 注意这里遍历背包顺序又变成了正序，和01背包不同，很重要 for (int j = weight[i - 1]; j &lt;= n; j++) { dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); }} 这里完全背包一维dp数组可以交换遍历顺序吗？和01背包不同，这里是可以的！因为dp[j]是用到其左边的数据dp[j - weight[i]]的，而先遍历背包再遍历物品也是满足的。 打印dp数组略 一维数组完整代码12345678910// m为物品的个数，n为背包的容量int m = weight.length, n = bagWeight;int[] dp = new int[n + 1];for (int i = 1; i &lt;= m; i++) { // 注意这里遍历背包顺序又变成了正序，和01背包不同，很重要 for (int j = weight[i - 1]; j &lt;= n; j++) { dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]); }}return dp[n];","link":"/2022/complete-knapsack-problem-solving-method/"},{"title":"动态规划解题方法","text":"动态规划通常用来求某个问题的最优解，将一个问题分解成若干个子问题，先求解子问题，然后从子问题的解中慢慢推导得到原问题的解。 动态规划算是做算法题时一种比较难的算法，记录一下从代码随想录的动态规划解题方法论中学到的动规做题五部曲。 动态规划题目类型 动规基础(入门：斐波那契数列、爬楼梯等) 背包问题 打家劫舍 股票问题 子序列问题 区间dp、概率dp(算法拔尖题) 动规五部曲1.确定dp数组以及下标的含义需要明白做题所定义的dp数组到底表示什么含义，以及当dp数组为一维数组时，dp[i]表示什么；当dp数组为二维数组时，dp[i][j]中的i和j分别表示什么含义。 2.递推公式(状态转移方程式)想出递推公式才能够顺利解题。 3.dp数组的初始化想明白问题最初的子问题的解是什么，初始化的值对了后面的推导才是正确的。 4.dp数组的遍历顺序考虑清楚dp数组的遍历顺序，比如有正向dp和反向dp，反向dp就会从dp数组的末尾往前推导。再比如背包问题：是先遍历背包后遍历物品还是先遍历物品再遍历背包。 5.打印dp数组当结果不对时，往往因为动规的代码比较简单而很难推断是哪里出了问题，那么将dp数组中的每一个值打印出来就能方便调试。","link":"/2022/dynamic-programming-solving-method/"},{"title":"Hexo网站百度谷歌收录注意事项","text":"记录一下处理百度谷歌收录本网站时遇到的问题以及注意事项。 百度、谷歌收录验证文件问题由于自己没有个人专属域名，直接使用Github Pages提供的username.github.io域名方式，所以百度、谷歌收录时的验证方式都选择文件验证的方式，它们会有一个html验证文件让放在网站的根目录下。 错误做法网上大多数的说法都是说直接把该文件放到Hexo博客根目录的source目录下，然后编译打包上传到远程仓库，但是事实上这种做法是有问题的，当执行hexo g生成静态界面的时候，hexo会把多余的内容添加到source目录下的这个html验证文件中，导致百度、谷歌验证失败。 正确做法验证文件存放在Hexo博客根目录的source目录下，在验证文件头部添加layout: false，以谷歌验证文件为例： 1234---layout: false---google-site-verification: googlexxxxxx.html 这样hexo g执行成功后，这个html验证文件中就不会有多余的内容，然后执行hexo d上传到远程仓库，这样百度、谷歌都验证成功了，为了保证一直验证成功，建议不要删除这个验证文件。 百度、谷歌收录站点地图(sitemap)获取不到问题虽然按照网上的教程使用npm下载相关依赖后(npm命令如下)， 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 执行hexo g能够在public目录下自动生成网站的sitemap，并且部署到Github上时直接通过url也能访问到sitemap.xml，但是百度、谷歌还是显示获取不到。 解决方法首先，需要在hexo配置文件_config.yml中配置sitemap： 12345# automatically generate sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 这样才不会生成多余的sitemap.txt和baidusitemap.txt。配置完sitemap可能还是不行，然后通过google搜索后发现，大家都有遇到类似的问题，根据大神的说法，可能不是Hexo的问题，应该是Github Pages的问题。Github Pages默认是基于Jekyll构建的，如果不是基于此方式构建的，Github Pages会忽略掉一些文件和文件夹。 因此，在Hexo博客的source文件夹下添加一个.nojekyll空文件，该文件会告诉Github Pages当前网站不是基于Jekyll构建的，不要忽略掉一些文件和文件夹。然后打开根目录下的_config.yml，找到include files区域，修改成下面这样， 123456# Include / Exclude file(s)## include:/exclude: options only apply to the 'source/' folderinclude: - .nojekyllexclude: nullignore: null 然后再**在deploy区域，添加ignore_hidden属性并设为false**。 12345# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: # 上面部分省略 ignore_hidden: false 这样在hexo g时就会把.nojekyll文件添加到public目录下，hexo d时会把.nojekyll文件推送到github上。","link":"/2022/hexo-seo-note/"},{"title":"LeetCode动态规划之背包问题必刷题目","text":"按照以下顺序刷题，能对动态规划之背包问题有更深刻的理解。 0-1背包 416. 分割等和子集 1049. 最后一块石头的重量 II 494. 目标和 474. 一和零 879. 盈利计划 完全背包 518. 零钱兑换 II 377. 组合总和 Ⅳ 70. 爬楼梯 322. 零钱兑换 279. 完全平方数 139. 单词拆分 1449. 数位成本和为目标值的最大数字","link":"/2022/knapsack-problem-leetcode-classic-problems/"},{"title":"LeetCode动态规划之打家劫舍问题必刷题目","text":"按照以下顺序刷题，能对动态规划之打家劫舍问题有更深刻的理解。 198. 打家劫舍 213. 打家劫舍 II 337. 打家劫舍 III","link":"/2022/house-robber-leetcode-classic-problems/"},{"title":"LRU算法","text":"LRU(Least Recently Used)算法，即最近最少使用算法，是置换算法(也叫淘汰算法)的一种，最早是在学习操作系统时接触的。 原理当内存不足时，选择淘汰最久未使用的页面。 实现方法实现方法有两种。 计时法对于每个页面增加一个访问时间计时器。每当一个页面被访问时，当时的绝对时钟时间记录到被访问页面的计时器中；淘汰时，选取访问时间计时器中值最小的页面淘汰。 双向链表法(常用)按照页面最后一次访问的时间次序将页面依次排列，最近被访问的页面排在队首，之前最久被访问的页面排在队尾。当一个页面被访问时，将这个页面排到队首；淘汰时，直接淘汰队尾那个最久未使用的页面即可。 LeetCode上实现LRU算法的题目：146. LRU 缓存。 使用Java JDK中封装的数据结构LinkedHashMap实现 123456789101112131415161718192021public class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt; { private int capacity; public LRUCache(int capacity) { super(capacity, 0.75f, true); this.capacity = capacity; } public int get(int key) { return super.getOrDefault(key, -1); } public void put(int key, int value) { super.put(key, value); } @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) { return size() &gt; capacity; }} 使用哈希表+双向链表实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public static class LRUCache { private int capacity; private HashMap&lt;Integer, Node&gt; hashMap = new HashMap&lt;&gt;(); private int size; private Node head = new Node(); private Node tail = new Node(); public LRUCache(int capacity) { this.capacity = capacity; this.size = 0; head.next = tail; tail.pre = head; } public int get(int key) { Node node = hashMap.get(key); if (node == null) { return -1; } // 移动该节点到表头第一位置 moveNewestNode(node); return node.value; } public void put(int key, int value) { Node node = hashMap.get(key); if (node == null) { node = new Node(key, value); hashMap.put(key, node); // 添加该节点到表头第一位置 addNode(node); } else { node.value = value; // 移动该节点到表头第一位置 moveNewestNode(node); return; } if (size &gt; capacity) { // 删除最老的节点 removeEldestNode(tail.pre); } } /** * 向链表开头添加元素 * * @param node 节点 */ private void addNode(Node node) { node.next = head.next; head.next.pre = node; node.pre = head; head.next = node; size++; } /** * 移动节点到表头 * * @param node 节点 */ private void moveNewestNode(Node node) { Node pre = node.pre, next = node.next; if (pre != null &amp;&amp; next != null) { pre.next = next; next.pre = pre; } node.next = head.next; head.next.pre = node; node.pre = head; head.next = node; } /** * 删除最老的节点 * * @param node 节点 */ private void removeEldestNode(Node node) { Node pre = node.pre, next = node.next; pre.next = next; next.pre = pre; node.pre = null; node.next = null; hashMap.remove(node.key, node); size--; } private class Node { private int key; private int value; private Node pre; private Node next; public Node() { } public Node(int key, int value) { this.key = key; this.value = value; } }}","link":"/2022/lru-algorithm/"},{"title":"LFU算法","text":"LFU(Least Frequently Used)算法，即最不经常使用算法，是置换算法(也叫淘汰算法)的一种，最早是在学习操作系统时接触的。 原理当内存不足时，选择淘汰访问次数最少的页面。 实现方法为每一个页面设置一个访问次数计数器。当一个页面刚被移到内存时，对应的计数器初始化为0；当一个页面被访问时，对应的计数器值加1；当需要淘汰时，取计数器值最小的页面，如果存在多个访问次数最少的页面，淘汰最近最久未使用的页面。 LeetCode上实现LFU算法的题目：460. LFU 缓存。 主要使用两个Map：cache用来存K, Node，Node中有K, V和使用频率；frequencyMap用来存使用频率对应的节点链表，该节点链表使用LinkedHashSet双向链表来存Node。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class LFUCache { private Map&lt;Integer, Node&gt; cache; private Map&lt;Integer, LinkedHashSet&lt;Node&gt;&gt; frequencyMap; private int capacity; private int size; private int minFrequency; public LFUCache(int capacity) { this.capacity = capacity; cache = new HashMap&lt;&gt;(this.capacity); frequencyMap = new HashMap&lt;&gt;(); } public int get(int key) { Node node = cache.get(key); if (node == null) { return -1; } node.frequency++; // 将该Node移动到对应的频率队列中 addNodeToNewList(node); return node.value; } public void put(int key, int value) { if (capacity == 0) { return; } Node node = cache.get(key); if (node == null) { node = new Node(key, value); // 必须在这里判断是否要移除最不经常使用的节点，不然新加入的节点就直接被移除了 if (size == capacity) { // 移除最不经常使用的节点 removeEldestNode(); } cache.put(key, node); minFrequency = 0; size++; } else { node.value = value; node.frequency++; } // 将该Node移动到对应的频率队列中 addNodeToNewList(node); } /** * 将Node移动到对应的频率队列中 * * @param node 节点 */ private void addNodeToNewList(Node node) { if (node.frequency &gt; 0) { // 将该节点从原先的队列删除 removeNodeOnOldList(node); } // 将该节点加入新的频率队列 LinkedHashSet&lt;Node&gt; frequencyList = frequencyMap.get(node.frequency); if (frequencyList == null) { frequencyList = new LinkedHashSet&lt;&gt;(); frequencyMap.put(node.frequency, frequencyList); } frequencyList.add(node); } /** * 移除最不经常使用的节点 */ private void removeEldestNode() { LinkedHashSet&lt;Node&gt; minFrequencyList = frequencyMap.get(minFrequency); Node eldestNode = minFrequencyList.iterator().next(); if (minFrequencyList.size() == 1) { frequencyMap.remove(minFrequency); // 这里不用minFrequency++，因为移除最不经常使用的节点一定发生在添加新节点时，那么之后minFrequency一定为0 } else { minFrequencyList.remove(eldestNode); } cache.remove(eldestNode.key); size--; } /** * 将节点从原先的队列删除 * * @param node */ private void removeNodeOnOldList(Node node) { int oldFrequency = node.frequency - 1; LinkedHashSet&lt;Node&gt; oldFrequencyList = frequencyMap.get(oldFrequency); if (oldFrequencyList.size() == 1) { frequencyMap.remove(oldFrequency); if (minFrequency == oldFrequency) { minFrequency = node.frequency; } } else { oldFrequencyList.remove(node); } } private class Node { private int key; private int value; // 使用频率 private int frequency; public Node(int key, int value) { this.key = key; this.value = value; } }} 缺点该算法的不足之处是：以前曾经多次使用的页面，虽然目前不用也会留在内存，而刚刚移入内存的页面因其访问次数很少反而会被淘汰。","link":"/2022/lfu-algorithm/"},{"title":"归并排序","text":"归并排序，经典的排序算法，基于分而治之的思想。 核心思想要将一个数组排序，可以先（递归地）将它分成两半，分别对这两半排序，然后再将结果归并起来。 时间复杂度时间复杂度为O(nlogn)。 空间复杂度空间复杂度为O(n)，因为需要一个额外O*(*n)空间的辅助数组来帮助归并过程。 稳定性稳定。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public int[] sortArray(int[] nums) { mergeSort(nums, 0, nums.length - 1); return nums;}/** * 归并排序 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:00 */private void mergeSort(int[] nums, int left, int right) { if (left &lt; right) { int mid = left + (right - left) / 2; /** * 分治思想：同时对左半区间和右半区间排序 * 排序完后再合并 */ mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); // 利用辅助数组合并 merge(nums, left, mid, right); }}/** * 合并区间 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param mid 中间点 * @param right 右边界 * @date 2022/2/19 13:00 */private void merge(int[] nums, int left, int mid, int right) { int[] temp = new int[right - left + 1]; int i = left, j = mid + 1, k = 0; // 将小的先添加进去 while (i &lt;= mid &amp;&amp; j &lt;= right) { temp[k++] = (nums[i] &lt; nums[j]) ? nums[i++] : nums[j++]; } // 左半区剩余 while (i &lt;= mid) { temp[k++] = nums[i++]; } // 右半区剩余 while (j &lt;= right) { temp[k++] = nums[j++]; } // 更新原数组 for (i = 0; i &lt; temp.length; i++) { nums[i + left] = temp[i]; }}","link":"/2022/merge-sort/"},{"title":"快速排序","text":"快速排序，经典的排序算法，用到了递归。 核心思想要将一个数组排序，先随机以一个数为基准，将比其大的数放到其右边，比其小的数放到其左边，然后再递归排以这个数为中心的左半区间和右半区间。 注意点一定要随机化选择切分元素(pivot)，否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢。 时间复杂度时间复杂度为O(nlogn)。 空间复杂度空间复杂度为O(h)，其中h为快速排序递归调用的层数。我们需要额外的O(h)的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需O(n)的空间，最优情况下每次都平衡，此时整个递归树高度为logn，空间复杂度为O(logn)。 稳定性不稳定。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums;}/** * 快速排序 * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:35 */private void quickSort(int[] nums, int left, int right) { if (left &lt; right) { /** * 核心思想：以一个数为基准，将比其大的数放到其右边，比其小的数放到其左边 * 然后再递归排以这个数为中心的左半区间和右半区间 */ int i = partition(nums, left, right); quickSort(nums, left, i - 1); quickSort(nums, i + 1, right); }}/** * 分隔(选取一个数作为基准，将比其大的数放到其右边，比其小的数放到其左边) * * @author chengzhy * @param nums 需要排序的数组 * @param left 左边界 * @param right 右边界 * @date 2022/2/19 13:35 * @return 分隔后基准数的下标值 */private int partition(int[] nums, int left, int right) { /** * 优化点：针对特殊测试用例：顺序数组或者逆序数组，一定要随机化选择切分元素（pivot）， * 否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢 */ int randomIndex = left + new Random().nextInt(right - left + 1); int temp = nums[left]; nums[left] = nums[randomIndex]; nums[randomIndex] = temp; // 将区间的第一个数作为基准 int base = nums[left]; int i = left, j = right; while (i &lt; j) { // 循环找比基数小和比基数大的数 // 先去找第一个比基数小的数的位置 while (base &lt;= nums[j] &amp;&amp; i &lt; j) { j--; } // 再去找第一个比基数大的数的位置 while (base &gt;= nums[i] &amp;&amp; i &lt; j) { i++; } if (i &lt; j) { // 如果i在j的左边，则交换两个位置的数 temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } // 将基数放至中心位置 nums[left] = nums[i]; nums[i] = base; // 返回基数的位置 return i;}","link":"/2022/quick-sort/"},{"title":"Kubernetes组件","text":"结合自己的理解来学习记录k8s各个组件的功能。 简述k8s一般都是以集群模式在生产环境中启动的，每个机器可以称为一个节点。这种模式就像公司，都会有一个主节点(高层领导)来管理其它节点(普通员工)，这个主节点称为master节点，主节点一般不干重活，只负责管理，所以主节点一般不会去负责应用的部署；应用部署的工作交由其它节点来做，这些节点被称为工作节点即worker节点。 当然，master节点如果只有一个是不可靠的，因为如果这个master节点机器宕机了，那整个k8s集群将不可用，所以master节点一般有多个(奇数)来保证集群的高可用。多个master节点组成类似公司董事会股东的角色，会通过选举机制(投票少数服从多数)选出一个CEO来负责管理工作节点，一旦这个CEO所在机器宕机了，这些master节点会重新选举出一个新的CEO来主持工作，这样集群就能保证高可用。 总结，Kubernetes Cluster = N master Node + N worker Node，N &gt;= 1。 以下摘自官方文档： 当你部署完 Kubernetes, 即拥有了一个完整的集群。 一个 Kubernetes 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。 工作节点托管作为应用负载的组件的 Pod 。控制平面管理集群中的工作节点和 Pod 。 为集群提供故障转移和高可用性，这些控制平面一般跨多主机运行，集群跨多个节点运行。 本文档概述了交付正常运行的 Kubernetes 集群所需的各种组件。 官方文档写的有些难理解，这里可以将k8s集群理解为生活中的一个集团(公司)。 控制平面组件（Control Plane Components）控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 replicas 字段时，启动新的 pod）。 控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅使用 kubeadm 构建高可用性集群 中关于跨多机器控制平面设置的示例。 个人理解：控制平面相当于集团的总部，是最核心的地方，一般是在master节点上的，每个worker节点要干什么任务都是由这里发号施令的。 kube-apiserverAPI 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。 Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。 个人理解：里面有各种操作的api，角色上相当于集团中最普通的员工(打工人)，脏活累活都是这里干的，而且集群中其它组件想和别的组件交互都得通过这里，这里就相当于中介，注意只有这里能和worker节点交互，和worker节点交互时具体是和worker节点上的kubelet交互的。 etcdetcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。 您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。 要了解 etcd 更深层次的信息，请参考 etcd 文档。 个人理解：数据库，Kubernetes所有集群数据都保存在这里。 kube-scheduler控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。 调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。 个人理解：集团中的调度者，负责做出让Pod在合适的节点上运行的调度策略，其中一些调度的数据存入etcd的操作和选择Pod在哪个机器上都是通过apiserver来完成的。 kube-controller-manager运行控制器进程的控制平面组件。 从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应 任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod) 服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌 个人理解：可以理解为集团内的总经理(决策者)，决定worker节点要干什么，但是这里不直接和worker节点联系，而是通过apiserver这个普通员工来和worker节点取得联系；其中的一些k8s集群数据也是通过apiserver来将数据存入etcd中的。 cloud-controller-manager云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。 cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。 与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。 下面的控制器都包含对云平台驱动的依赖： 节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除 路由控制器（Route Controller）: 用于在底层云基础架构中设置路由 服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器 个人理解：其它云平台上的controller-manager(cm)。 Node 组件节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。 kubelet一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都 运行在 Pod 中。 kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。 个人理解：当前worker节点上的总代理，相当于集团子公司的一把手。可以监控所在的worker节点的运行情况，要想和控制平面组件交互都是通过与apiserver交互实现的。 kube-proxykube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。 kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。 如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。 个人理解：负责网络代理、路由，维护网络规则，有点像网络中心的角色，功能上类似注册中心。工作节点的ip可以转变成服务名供其它访问，类似于微服务中的以服务名相互调用，当一个请求到达时这里可以负责路由找到其对应的是哪个Pod。每个worker节点上的kube-proxy都能相互联系。 容器运行时（Container Runtime）容器运行环境是负责运行容器的软件。 Kubernetes 支持容器运行时，例如 Docker、 containerd、CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。 插件（Addons）插件使用 Kubernetes 资源（DaemonSet、 Deployment等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 kube-system 命名空间。 下面描述众多插件中的几种。有关可用插件的完整列表，请参见 插件（Addons）。 DNS尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该 有集群 DNS， 因为很多示例都需要 DNS 服务。 集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。 Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。 Web 界面（仪表盘）Dashboard 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身并进行故障排除。 个人理解：k8s系统的前端界面。 容器资源监控容器资源监控 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供用于浏览这些数据的界面。 个人理解：可以集成第三方组件，目前主流的是Prometheus + Grafana。 集群层面日志集群层面日志 机制负责将容器的日志数据 保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。 个人理解：可以集成第三方组件，比如ELK和EFK，Elasticsearch、Logstash、Fluentd、Kibana。","link":"/2022/kubernetes-components/"},{"title":"MySQL安装指南","text":"记录一下MySQL安装过程。 安装Windows从MySQL官网下载解压版，解压至本地。 配置Windows打开此电脑 – 右键后选择属性 – 选择高级系统设置 – 点击环境变量 – 在系统环境变量Path中添加mysql路径(…\\bin)，验证是否配置成功，打开cmd，输入mysql：提示Can't connect to MySQL server on 'localhost'则证明添加成功；提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加失败，请重新检查步骤并重试。 新建配置文件my.ini放在存放mysql的根目录下，my.ini可以配置如端口、连接数等设定：(MySQL的版本≥5.5.3，可以把编码设置为utf8mb4，utf8mb4和utf8完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。) 1234567[mysqld]default-storage-engine = INNODB# 服务端使用的字符集默认为utf8mb4character-set-server = utf8mb4collation-server = utf8mb4_general_ci[client]default-character-set = utf8mb4 启动Windows初始化：管理员身份cmd输入mysqld --initialize-insecure，若无报错可以看到MySQL安装目录下已经有data目录生成。 注册服务：管理员身份cmd输入mysqld -install 启动服务：管理员身份cmd输入net start mysql 修改root用户默认密码：管理员身份cmd输入mysqladmin -u root password xxxx 登录：管理员身份cmd输入mysql -uroot -pxxxx 停止服务：管理员身份cmd输入net stop mysql 卸载mysql：停止服务后，管理员身份cmd输入mysqld -remove mysql，最后删除MySQL目录及相关的环境变量。","link":"/2022/mysql-installation-guide/"},{"title":"解决Maven无法下载依赖问题","text":"在使用IDEA开发过程中遇到了Maven无法下载依赖的问题，这里记录一下解决方法，主要参考解决maven无法下载jar包的问题！这篇文章。 配置Maven镜像Maven默认仓库国内有时候会连不上，所以需要配置镜像仓库来代替。一些常用的镜像仓库如下： 12345678910111213141516171819202122232425262728293031&lt;!-- 阿里云maven --&gt;&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;&lt;!-- maven官方镜像 --&gt;&lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;https://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 阿里云镜像 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://central.maven.org/maven2&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 阿里云镜像 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt; 注意：镜像仓库地址要使用https，使用http会报错（自2020年1月15日起，中央存储库不再支持通过纯HTTP进行的不安全通信，并且要求对存储库的所有请求都通过HTTPS进行加密。） IDEA中Maven配置 Maven–Importing中的VM options for importer中添加配置： 1-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true Maven–Runner中的VM Options中添加配置： 1234-Dmaven.multiModuleProjectDirectory=$MAVEN_HOME-Dmaven.wagon.http.ssl.insecure=true-Dmaven.wagon.http.ssl.allowall=true-Dmaven.wagon.http.ssl.ignore.validity.dates=true JDK配置打开https://repo1.maven.org/maven2/网址，下载该网址证书，此下载步骤这里省略，可自行搜索。 找到本地jdk目录中的jre\\lib\\security，本人电脑系统是Windows10，在此目录下打开命令提示符cmd，输入以下命令： 1keytool -import -alias cacerts -keystore cacerts -file 下载的证书存放地址 然后输入默认的密钥库口令：changeit，是否信任此证书输入：y，之后证书就添加到密钥库中了即本地jdk目录中的jre\\lib\\security下会出现一个cacerts文件。 清理Maven中下载失败的Jar包在本地Maven仓库目录进入cmd命令提示符，运行命令： 1for /r %i in (*.lastUpdated) do del %i 即可清理下载失败的Jar包。 最后手段如果上面方法尝试后还是不行，也可以去找现成的jar包放进Maven仓库对应的位置下。","link":"/2022/solve-maven-cannot-download-dependencies/"},{"title":"重识Spring Cloud","text":"虽然之前自己使用过Spring Cloud中的一些组件，但是对于整个Spring Cloud体系的认识还是不够深刻，现在整理一下学习到的知识，来重新认识Spring Cloud。 Spring Cloud是一种为构建分布式微服务系统而出现的一站式解决方案，具有庞大丰富的生态，它是基于Spring Boot之上，使得Java应用构建微服务更加的方便。 一般情况下，构建分布式微服务系统都需要服务注册中心、配置中心、负载均衡、网关、熔断和降级等等基础功能，Spring Cloud都提供了相对应的解决方案。 服务注册中心意义微服务架构下，服务划分众多，服务与服务之间的调用是不可避免的。如果没有服务注册中心，调用其它服务中的接口就需要知道服务提供方的ip和端口，这就会带来许多的问题。比如服务提供方中的一个应用实例突然崩溃，调用方如何再去调用该服务下其它应用实例中的相同接口来保证系统高可用呢？再比如服务提供方的ip会变化，难道调用方中的代码也要随时根据其改变而修改代码吗？ 诸多的不便就需要服务注册中心来解决，服务注册中心可以来管理服务，服务与服务之间的调用就通过服务注册中心这个中介来完成。 功能服务注册中心一般具有服务注册、服务续约、获取注册列表信息、服务下线、服务剔除等功能。 组件Spring Cloud集成的服务注册中心的组件有：Eureka、Zookeeper、Consul、Nacos等。 配置中心意义微服务架构下，服务众多，各个服务都会有属于自己的配置文件。如果在项目运行的时候需要修改某些应用的配置，没有配置中心，我们就需要去每个应用存放目录下一个个地修改对应的配置文件，然后再重启应用。 而有了配置中心，就可以对配置文件进行统一的管理，除此之外，配置中心还可以让修改配置文件时不需要重启应用就能让某些修改的配置项直接生效。 功能配置中心一般具有配置管理、配置项热更新、配置版本控制等功能。 注意点对于应用的配置，需要热更新的配置项放到配置中心意义比较大，基本不会变更的配置(例如数据库连接配置)放在微服务本地比较好。 组件Spring Cloud集成的配置中心的组件有：Nacos、Apollo、Spring Cloud Config等。 负载均衡意义微服务架构下为了支撑高并发，一个服务一般都拥有多个应用实例。如果没有负载均衡，所有的请求可能都只流入到对应服务下的其中一个应用实例，从而导致该应用实例崩溃，并且其它空闲的应用实例没有得到充分的利用。为了解决这种问题就必须要在服务中引入负载均衡策略。 功能负载均衡顾名思义就是提供了对请求负载均衡的功能。 组件Spring Cloud集成的负载均衡的组件有：Ribbon等。 网关意义当用户通过前台对系统发起请求，微服务架构下的服务众多，每个应用的ip和端口各不相同。如果没有网关，就会带来诸多的问题。比如访问后台接口需要直接通过ip和端口，如果下次应用部署的机器ip变了那前台代码还得跟着变。再比如整个系统会遭受许多网络攻击，没有网关那就需要每个应用都去解决网络攻击的问题，这就使代码变得重复冗余，每个团队负责的应用都得去实现这个重复的功能。 当然网关所能解决的问题不止这些，简单来讲网关是系统对外的唯一入口，介于客户端与服务器端之间。 功能一般来说，网关具有对请求鉴权、限流、 路由、监控等功能。当然，网关也是能以服务的形式注册到注册中心中的，好处就是可以通过注册中心拿到所有服务的元数据，拿到这些信息之后网关就可以通过路由映射将请求统一。 组件Spring Cloud集成的网关的组件有：Zuul、Spring Cloud Gateway等。 熔断和降级意义在微服务架构下，服务之间的相互调用十分常见，而调用失败导致的阻塞也是不可避免的。例如服务A调用服务B，服务B调用服务C，但是因为某些原因服务C崩溃了，这时候大量的请求会在服务C中阻塞，此时请求因为阻塞无法返回响应，就会导致服务A和服务B也一同阻塞，这就是一种服务雪崩。 熔断和降级的作用就是当这种情况出现的时候，超出一定阈值的时候就会将此请求链路进行处理，从而提高系统的弹性。 功能熔断就是当指定时间窗内的请求失败率达到设定阈值时，系统将通过断路器直接将此请求链路断开，以免导致服务雪崩的现象。 降级则是另一种较为友好的处理方式，提高了用户的体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户更友好的回复。 组件Spring Cloud集成的熔断和降级的组件有：Hystrix、Sentinel等。 Spring Cloud KubenetesSpring Cloud和Kubenetes在核心功能上有很大一部分交集，k8s中的Service有服务注册、负载均衡的能力，ConfigMap和Secret有配置管理的能力，Ingress可以作为统一网关，这些功能组件在Spring Cloud生态体系中都有类似的实现。 Spring Cloud Kubenetes这个项目是将k8s当作Spring Cloud微服务应用所需要的注册中心、配置中心，以此来简化微服务应用的整体架构，更好的和云原生环境进行融合。","link":"/2022/spring-cloud-introduction/"},{"title":"LeetCode动态规划之股票问题必刷题目","text":"按照以下顺序刷题，能对动态规划之股票问题有更深刻的理解。 121. 买卖股票的最佳时机 122. 买卖股票的最佳时机 II 123. 买卖股票的最佳时机 III 188. 买卖股票的最佳时机 IV 309. 最佳买卖股票时机含冷冻期 714. 买卖股票的最佳时机含手续费","link":"/2022/stock-problem-leetcode-classic-problems/"},{"title":"Kubernetes是什么？","text":"Kubernetes官方文档有点晦涩抽象，结合自己的理解来巩固一下学习到的Kubernetes知识点。 简介简单来说，k8s是一个大规模编排容器的管理系统。k8s是为了解决应用容器化部署的相关问题而诞生的，应用的部署方式经历了三个发展阶段：传统部署方式–&gt;虚拟化部署方式–&gt;容器化部署方式。 以下摘自官方文档： 传统部署时代： 早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。 个人理解：早期一般选择传统部署方式，应用都部署在一台物理服务器上，由于应用之间没有隔离性，可能由于应用A内存泄漏了，导致其它应用内存不足下线了，这种情况就十分不安全。 虚拟化部署时代： 作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。 虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。 每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。 个人理解：为了解决传统部署方式带来的问题，虚拟化部署方式是在物理服务器上通过虚拟化技术开通几个虚拟机，然后将应用部署到虚拟机上，由于虚拟机有隔离性，即使某个应用炸了，只会影响这个应用所在的虚拟机的环境，而其它虚拟机环境的应用仍然可以正常运行，但是虚拟机有一个缺点就是太笨重了，通常一个虚拟机需要几个G的大小。 容器部署时代： 容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。 容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处： 敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的 容器镜像构建和部署。 关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。 可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。 跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。 资源隔离：可预测的应用程序性能。 资源利用：高效率和高密度。 个人理解：为了解决虚拟机笨重的问题，Docker的出现开启了容器化的时代。每个容器镜像相比虚拟机来说很小，是轻量级的，每个应用都依赖镜像以容器化的方式部署，十分方便。 但是对于大型互联网公司的明星产品来说，用户体量所带来的巨大流量迫使应用采用微服务的架构模式，服务划分众多，比如订单服务、库存服务、短信服务等等，每个服务可能都需要十几个应用来支撑高并发，这么多的应用采用容器化部署的方式，并且可能不同的服务应用同时部署在好几十台物理服务器上，这种情况就会使得应用容器的管理十分复杂。而k8s的出现就是为了解决这种问题，并且它还有其它优点，总体来说k8s主要作用就是编排，编其实就是将相同的应用分组管理起来，排就是排列应用，可能应用A在一个物理服务器上挂了，k8s再将其在其它服务器上启动一个新的应用，只有先将应用编起来，才好排。 作用以下摘自官方文档： 容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？ 这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。 Kubernetes 为你提供： 服务发现和负载均衡 Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。 个人理解：相当于k8s有注册中心的功能，提供了通过服务名访问应用的方式，以及访问一个服务通过负载均衡将请求平衡到服务下的多个应用中，可以联想到Nacos的注册中心功能。 存储编排 Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。 个人理解：k8s提供一个统一的存储管理机制来管理应用所需的挂载到硬盘上的存储空间，应用需要存储空间时可以找k8s申请，当应用挂掉了k8s会将这个应用所申请的存储空间删除。 自动部署和回滚 你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。 个人理解：当一个发行版本有问题了，k8s可以很方便的将应用回滚到上一个稳定的版本。 自动完成装箱计算 Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。 自我修复 Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。 个人理解：当有三台机器都部署了应用A，有一天突然二号机器挂了，同时二号机器还部署了应用B，此时k8s能够监控到这种情况，会在k8s集群中选择一台其它的机器来启动应用A和应用B，而且只有在两个应该启动成功时才会通知给客户端。 密钥与配置管理 Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 个人理解：k8s可以管理每个应用的配置信息，类似于Spring Cloud中的配置中心功能，可以联想到Nacos的配置中心功能。","link":"/2022/what-is-kubernetes/"},{"title":"LeetCode动态规划之子序列问题必刷题目","text":"按照以下顺序刷题，能对动态规划之子序列问题有更深刻的理解。 300. 最长递增子序列 674. 最长连续递增序列 718. 最长重复子数组 1143. 最长公共子序列 1035. 不相交的线 53. 最大子数组和 392. 判断子序列 115. 不同的子序列 583. 两个字符串的删除操作 72. 编辑距离 647. 回文子串 516. 最长回文子序列","link":"/2022/subsequence-problem-leetcode-classic-problems/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Github Pages","slug":"Github-Pages","link":"/tags/Github-Pages/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"页面置换算法","slug":"页面置换算法","link":"/tags/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"},{"name":"LRU算法","slug":"LRU算法","link":"/tags/LRU%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"LFU算法","slug":"LFU算法","link":"/tags/LFU%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"云原生","slug":"云原生","link":"/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"容器","slug":"容器","link":"/tags/%E5%AE%B9%E5%99%A8/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"指南","slug":"指南","link":"/tags/%E6%8C%87%E5%8D%97/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/tags/Spring-Cloud/"},{"name":"微服务","slug":"微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包问题","slug":"算法/动态规划/背包问题","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"01背包","slug":"算法/动态规划/背包问题/01背包","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/01%E8%83%8C%E5%8C%85/"},{"name":"完全背包","slug":"算法/动态规划/背包问题/完全背包","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"打家劫舍","slug":"算法/动态规划/打家劫舍","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"name":"页面置换算法","slug":"算法/页面置换算法","link":"/categories/%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"},{"name":"SEO","slug":"Hexo/SEO","link":"/categories/Hexo/SEO/"},{"name":"排序算法","slug":"算法/排序算法","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"LRU算法","slug":"算法/页面置换算法/LRU算法","link":"/categories/%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/LRU%E7%AE%97%E6%B3%95/"},{"name":"Maven","slug":"Maven","link":"/categories/Maven/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/categories/Spring-Cloud/"},{"name":"LFU算法","slug":"算法/页面置换算法/LFU算法","link":"/categories/%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/LFU%E7%AE%97%E6%B3%95/"},{"name":"股票问题","slug":"算法/动态规划/股票问题","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"},{"name":"归并排序","slug":"算法/排序算法/归并排序","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"算法/排序算法/快速排序","link":"/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"概述","slug":"Kubernetes/概述","link":"/categories/Kubernetes/%E6%A6%82%E8%BF%B0/"},{"name":"安装","slug":"MySQL/安装","link":"/categories/MySQL/%E5%AE%89%E8%A3%85/"},{"name":"子序列问题","slug":"算法/动态规划/子序列问题","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"}]}